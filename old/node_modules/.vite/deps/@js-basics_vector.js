import "./chunk-F4AF7QOS.js";

// node_modules/@js-basics/vector/build/esm/index.mjs
function P(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function ft(r, t) {
  let { x: e, y: n, z: o } = t, { x: s, y: i, z: u, w: h } = r, c = h * e + i * o - u * n, f = h * n + u * e - s * o, d = h * o + s * n - i * e, V = -s * e - i * n - u * o, M = c * h + V * -s + f * -u - d * -i, at = f * h + V * -i + d * -s - c * -u, a = d * h + V * -u + c * -i - f * -s;
  return new t.constructor(M, at, a);
}
var Mt = Math.PI;
var Vt = Math.PI * 2;
function G(r) {
  let t = r % Vt;
  return t < -Mt ? t += Vt : t > Mt && (t -= Vt), t;
}
function Wt(r) {
  return r > -1 ? r < 1 ? Math.acos(r) : 0 : Mt;
}
function Yt(r, [t, e, n]) {
  let [o, s, i] = r;
  return new r.constructor(new o.constructor(o.x * t.x + s.x * t.y + i.x * t.z, o.y * t.x + s.y * t.y + i.y * t.z, o.z * t.x + s.z * t.y + i.z * t.z), new o.constructor(o.x * e.x + s.x * e.y + i.x * e.z, o.y * e.x + s.y * e.y + i.y * e.z, o.z * e.x + s.z * e.y + i.z * e.z), new o.constructor(o.x * n.x + s.x * n.y + i.x * n.z, o.y * n.x + s.y * n.y + i.y * n.z, o.z * n.x + s.z * n.y + i.z * n.z));
}
function Ut(r, { x: t, y: e, z: n }) {
  let [o, s, i] = r;
  return new o.constructor(o.x * t + s.x * e + i.x * n, o.y * t + s.y * e + i.y * n, o.z * t + s.z * e + i.z * n);
}
function Zt(r, [t, e, n]) {
  return new r.constructor(r.dot(t), r.dot(e), r.dot(n));
}
function x(r) {
  return typeof r == "number" || (r == null ? void 0 : r.constructor) === Number;
}
var et = 0;
var Ct = 1;
var At = 2;
var Tt = 3;
var mt = 9999999999999;
var pt = void 0;
var jt = Symbol("vector length");
var dt = Symbol("get source");
var Qt = Symbol("checked");
var S = pt;
var k;
var j;
var er = [0, 1, 2, 6, 24, 120, 720, 5760, 51840, 518400, 5702400, 68428800, 889574400, 12454041600, 186810624e3];
var bt = [];
var A = -1;
var qt = false;
var yt = [];
function Nt(r, t, e) {
  S = r, A = -1, j = 1;
  let n = t(e);
  if (!x(n))
    throw new Error(`
      your assigned progress did not not return a primitive!
      calc() does not support logical operators (|| && ==) directly

      instead of calc(() => v1 || v2);
      use        calc(() => +v1 || +v2);

      instead of calc(() => v1);
      use        calc(v1);
      `);
  return n;
}
function wt(r) {
  let t = r[dt];
  return t ? t(r).length : r[jt] || 3;
}
function nr(r, t) {
  return wt(r) > wt(t) ? r : t;
}
function or(r, t) {
  if (j += 1, t === mt)
    return j;
  if (t >= wt(r))
    return 0;
  let e = r[dt];
  if (e)
    return 1 * e(r)[t];
  if (t === et)
    return 1 * r.x;
  if (t === Ct)
    return 1 * r.y;
  if (t === At)
    return 1 * r.z;
  if (t === Tt)
    return 1 * r.w;
}
function $t(r, t, e) {
  let n = r[dt];
  if (n) {
    n(r)[t] = e;
    return;
  }
  if (t === et) {
    r.x = e;
    return;
  }
  if (t === Ct) {
    r.y = e;
    return;
  }
  t === At && (r.z = e), t === Tt && (r.w = e);
}
function q(r, t) {
  if (typeof r != "function")
    throw new Error("no function assigned");
  if (S !== pt)
    throw new Error("something wrong, do you use calc() inside calc?");
  try {
    let e = typeof t > "u", n = typeof t == "function", o = !n && !e ? t : void 0, s = Nt(et, r, o);
    if (e && typeof k > "u")
      return s;
    let i = k ? wt(k) : 0;
    if (i === mt) {
      if (!r[Qt]) {
        let f = Nt(mt, r), d = er[j];
        if (Math.abs(f - d) > Number.EPSILON)
          throw new Error(`
            algebraic multiplication works only in calls with *

            calc(() => v * m);
            calc(() => m * v);
            calc(() => m * m);
            calc(() => m * m * v);

            `);
        r[Qt] = true;
      }
      let c = bt[0];
      for (let f = 1; f < j - 1; f += 1) {
        let d = bt[f];
        if (!c.multiply)
          throw new Error(`cannot find method multiply() on ${c}`);
        c = c.multiply(d);
      }
      return c;
    }
    let u = n ? t.length : i;
    if (u || (u = i), u < i)
      throw new Error("Your assigned result Vector cant use higher space Operands than it has");
    let h = new Array(u);
    h[0] = s, o && $t(o, S, h[0]);
    for (let c = 1; c < u; c += 1) {
      let f = Nt(c, r, o);
      h[c] = f, o && $t(o, S, f);
    }
    return e ? new k.constructor(...h) : n ? t(...h) : o;
  } finally {
    S = pt, k = void 0;
  }
}
function N(r, t) {
  let e = r.prototype;
  e[dt] = t;
  let n = "valueOf", o = e[n];
  e[n] = function() {
    return S === et && (k = k ? nr(k, this) : this, bt[j - 1] = this), S === pt ? o.call(this) : or(this, S);
  };
}
function _t(r) {
  return function(...t) {
    if (S === et) {
      if (qt)
        return r.apply(this, t);
      try {
        qt = true, A += 1;
        let e = r.apply(this, t);
        return yt[A] = e, e;
      } finally {
        qt = false;
      }
    }
    return S === Ct || S === At || S === Tt ? (A += 1, yt[A]) : r.apply(this, t);
  };
}
function m(r, t) {
  let e = r.prototype, n = e[t];
  e[t] = _t(n);
}
function B(r, t) {
  let e = r.prototype, n = Object.getOwnPropertyDescriptor(e, t);
  Object.defineProperty(e, t, { get: _t(function() {
    return n.get.call(this);
  }) });
}
function X(r, t) {
  let e = r.prototype;
  Object.defineProperty(e, jt, { value: t });
}
function xt(r) {
  X(r, mt);
}
function E(r) {
  return _t(r);
}
function sr(r) {
  let t = "";
  return r && (t = `${r}-`), t;
}
function b(r, t, e = {}) {
  let n = sr(r);
  return Object.entries(t).forEach(([o, s]) => {
    e[`--${n}${o}`] = s;
  }), e;
}
var Rt = 0;
var Ft = 1;
var O = Symbol("axes");
function ir(r, t, e, n) {
  let o = Math.atan2(r, t), s = Math.atan2(e, n);
  return G(o - s);
}
function Bt(r) {
  return r * r;
}
var g = class {
  constructor(t, e) {
    typeof t == "function" ? q(t, (n, o) => {
      this[O] = [n, o];
    }) : P(t) ? this[O] = [...t] : t && x(t.x) ? this[O] = [t.x || 0, t.y || 0] : this[O] = [t || 0, e || 0];
  }
  valueOf() {
    throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc");
  }
  normalize() {
    let { length: t } = this;
    return new this.constructor(this.x / t, this.y / t);
  }
  norm() {
    return this.normalize();
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  getRad() {
    return G(Math.atan2(this.y, this.x));
  }
  angleTo(t) {
    return ir(this.y, this.x, t.y, t.x);
  }
  rotate(t) {
    let e = Math.sin(t), n = Math.cos(t), o = this.x * n - this.y * e, s = this.x * e + this.y * n;
    return new this.constructor(o, s);
  }
  distance(t) {
    return Math.sqrt(Bt(this.x - t.x) + Bt(this.y - t.y));
  }
  dist(t) {
    return this.distance(t);
  }
  toArray() {
    return [this.x, this.y];
  }
  calc(t) {
    throw new Error("calc() not implemented");
  }
  clone() {
    throw new Error("clone() not implemented");
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  toJSON() {
    return { x: this.x, y: this.y };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toCSSVars(t, e) {
    return b(t, this.toJSON(), e);
  }
  get lengthSq() {
    return this.dot(this);
  }
  get length() {
    return Math.sqrt(this.lengthSq);
  }
  get lensq() {
    return this.lengthSq;
  }
  get len() {
    return this.length;
  }
  get x() {
    return this[O][Rt];
  }
  set x(t) {
    throw new Error("set x() not implemented");
  }
  get y() {
    return this[O][Ft];
  }
  set y(t) {
    throw new Error("set y() not implemented");
  }
  get z() {
    throw new Error("get z() not implemented");
  }
  set z(t) {
    throw new Error("set z() not implemented");
  }
  [Symbol.iterator]() {
    return this[O].values();
  }
};
N(g);
X(g, 2);
m(g, "dot");
m(g, "angleTo");
m(g, "distance");
m(g, "toArray");
m(g, "getRad");
B(g, "length");
B(g, "lengthSq");
var W = class extends g {
  set x(t) {
    this[O][Rt] = t;
  }
  set y(t) {
    this[O][Ft] = t;
  }
  get x() {
    return this[O][Rt];
  }
  get y() {
    return this[O][Ft];
  }
  calc(t) {
    return q(t, this);
  }
  clone() {
    return new W(this.x, this.y);
  }
};
var T = class extends g {
  toPoint() {
    return new W(this.x, this.y);
  }
};
var cr = E((r, t) => new W(r, t));
var ur = (r, t) => cr(r, t);
var hr = E((r, t) => new T(r, t));
var gt = (r, t) => hr(r, t);
var Xr = gt(0, 0);
var Wr = gt(0, -1);
var Yr = gt(-1, 0);
var K = 0;
var v = 1;
var tt = 2;
var l = Symbol("axes");
function Jt(r) {
  return r * r;
}
var w = class {
  constructor(t, e, n) {
    typeof t == "function" ? q(t, (o, s, i) => {
      this[l] = [o, s, i];
    }) : P(t) ? this[l] = [...t] : t && x(t.x) ? this[l] = [t.x || 0, t.y || 0, t.z || 0] : this[l] = [t || 0, e || 0, n || 0];
  }
  valueOf() {
    throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc");
  }
  normalize() {
    let { length: t } = this;
    return new this.constructor(this.x / t, this.y / t, this.z / t);
  }
  norm() {
    return this.normalize();
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  cross(t) {
    return new this.constructor(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x);
  }
  crossNormalize(t) {
    let e = this.cross(t), { length: n } = e;
    return e[l][K] /= n, e[l][v] /= n, e[l][tt] /= n, e;
  }
  cn(t) {
    return this.crossNormalize(t);
  }
  toAngles() {
    return { theta: Math.atan2(this.z, this.x), phi: Math.asin(this.y / this.length) };
  }
  angleTo(t) {
    return G(Wt(this.dot(t) / (this.length * t.length)));
  }
  multiply(t) {
    return t.x === void 0 ? this.multiplyMat3(t) : t.w === void 0 ? this.multiplyVec3(t) : ft(t, this);
  }
  multiplyMat3(t) {
    return Zt(this, t);
  }
  multiplyVec3({ x: t, y: e, z: n }) {
    return new this.constructor(this.x * t, this.y * e, this.z * n);
  }
  distance(t) {
    return Math.sqrt(Jt(this.x - t.x) + Jt(this.y - t.y) + Jt(this.z - t.z));
  }
  dist(t) {
    return this.distance(t);
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  swizzle(t) {
    let e = t.split("").map((n) => this[n]);
    return e.length === 2 ? new T(e[0], e[1]) : new this.constructor(e[0], e[1], e[2]);
  }
  calc(t) {
    throw new Error("calc() not implemented");
  }
  clone() {
    throw new Error("clone() not implemented");
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  toJSON() {
    return { x: this.x, y: this.y, z: this.z };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toCSSVars(t, e) {
    return b(t, this.toJSON(), e);
  }
  get lengthSq() {
    return this.dot(this);
  }
  set lengthSq(t) {
    throw new Error("set lengthSq() not implemented");
  }
  get length() {
    return Math.sqrt(this.lengthSq);
  }
  set length(t) {
    throw new Error("set length() not implemented");
  }
  get lensq() {
    return this.lengthSq;
  }
  set lensq(t) {
    throw new Error("set lensq() not implemented");
  }
  get len() {
    return this.length;
  }
  set len(t) {
    throw new Error("set len() not implemented");
  }
  get x() {
    return this[l][K];
  }
  set x(t) {
    throw new Error("set x() not implemented");
  }
  get y() {
    return this[l][v];
  }
  set y(t) {
    throw new Error("set y() not implemented");
  }
  get z() {
    return this[l][tt];
  }
  set z(t) {
    throw new Error("set z() not implemented");
  }
  get xy() {
    return new T(this[l][K], this[l][v]);
  }
  set xy(t) {
    throw new Error("set xz() not implemented");
  }
  get xz() {
    return new T(this[l][K], this[l][tt]);
  }
  set xz(t) {
    throw new Error("set xz() not implemented");
  }
  get yz() {
    return new T(this[l][v], this[l][tt]);
  }
  set yz(t) {
    throw new Error("set yz() not implemented");
  }
  [Symbol.iterator]() {
    return this[l].values();
  }
};
N(w);
X(w, 3);
m(w, "dot");
m(w, "cross");
m(w, "crossNormalize");
m(w, "toAngles");
m(w, "angleTo");
m(w, "rotate");
m(w, "distance");
m(w, "toArray");
B(w, "length");
B(w, "lengthSq");
var _ = class extends w {
  set x(t) {
    this[l][K] = t;
  }
  set y(t) {
    this[l][v] = t;
  }
  set z(t) {
    this[l][tt] = t;
  }
  get x() {
    return this[l][K];
  }
  get y() {
    return this[l][v];
  }
  get z() {
    return this[l][tt];
  }
  calc(t) {
    return q(t, this);
  }
  clone() {
    return new _(this.x, this.y, this.z);
  }
};
var nt = class extends w {
  toVector() {
    return new _(this.x, this.y, this.z);
  }
  clone() {
    return this;
  }
};
var lr = E((r, t, e) => new _(r, t, e));
var ar = (r, t, e) => lr(r, t, e);
var fr = E((r, t, e) => new nt(r, t, e));
var C = (r, t, e) => fr(r, t, e);
var Br = C(0, 0, 0);
var ot = C(0, 0, -1);
var Kr = C(0, 0, 1);
var st = C(-1, 0, 0);
var It = C(1, 0, 0);
var it = C(0, 1, 0);
var vr = C(0, -1, 0);
var te = C(1, 1, 1);
var R = Symbol("angle rad");
var Kt = Math.PI / 180;
var oe = 180 / Math.PI;
var L = class {
  constructor(t) {
    t instanceof L ? this[R] = t[R] : this[R] = G(t * Kt);
  }
  valueOf() {
    return this[R];
  }
  toJSON() {
    return { angle: this[R] };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toCSSVars(t, e) {
    return b(t, this.toJSON(), e);
  }
};
var ct = class extends L {
  set(t) {
    t instanceof L ? this[R] = t[R] : this[R] = G((t || 0) * Kt);
  }
};
var rt = class extends L {
  toDegree() {
    return new ct(this[R]);
  }
};
var yr = new rt(0);
function Y(r) {
  return new ct(r);
}
function mr(r) {
  return r instanceof rt ? r : r ? new rt(r) : yr;
}
function vt(r) {
  return x(r) || r instanceof L;
}
var F = 0;
var J = 1;
var I = 2;
var D = 3;
var y = Symbol("axes");
var pr = Symbol("forward cache");
var wr = Symbol("left cache");
var dr = Symbol("up cache");
var xr = Symbol("inverse cache");
function gr([r, t, e, n]) {
  return Math.sqrt(r * r + t * t + e * e + n * n);
}
function tr(r) {
  let t = gr(r);
  r[F] /= t, r[J] /= t, r[I] /= t, r[D] /= t;
}
function zr(r, t) {
  let e = r.normalize(), n = t.crossNormalize(e), o = e.crossNormalize(n), s = n.x, i = n.y, u = n.z, h = o.x, c = o.y, f = o.z, d = e.x, V = e.y, M = e.z, at = s + c + M, a = new Array(4);
  if (at > 0) {
    let z = Math.sqrt(at + 1);
    return a[D] = z * 0.5, z = 0.5 / z, a[F] = (f - V) * z, a[J] = (d - u) * z, a[I] = (i - h) * z, a;
  }
  if (s >= c && s >= M) {
    let z = Math.sqrt(1 + s - c - M), H = 0.5 / z;
    return a[F] = 0.5 * z, a[J] = (i + h) * H, a[I] = (u + d) * H, a[D] = (f - V) * H, a;
  }
  if (c > M) {
    let z = Math.sqrt(1 + c - s - M), H = 0.5 / z;
    return a[F] = (h + i) * H, a[J] = 0.5 * z, a[I] = (V + f) * H, a[D] = (d - u) * H, a;
  }
  let Xt = Math.sqrt(1 + M - s - c), Ot = 0.5 / Xt;
  return a[F] = (d + u) * Ot, a[J] = (V + f) * Ot, a[I] = 0.5 * Xt, a[D] = (i - h) * Ot, a;
}
function Sr(r, t) {
  let e = new Array(4), n = t * 0.5, o = Math.sin(n), s = Math.cos(n);
  return e[F] = o * r.x, e[J] = o * r.y, e[I] = o * r.z, e[D] = s, e;
}
function Dt(r, t, e, n) {
  if (x(r))
    return [r, t, e, n];
  if (P(r))
    return [...r];
  if (vt(t))
    return Sr(r, t);
  if (r && t)
    return zr(r, t);
}
function rr(r, t, e, n) {
  return r && x(r.w) ? Dt(r.x, r.y, r.z, r.w) : Dt(r, t, e, n) || [0, 0, 0, 1];
}
var U = class {
  constructor(t, e, n, o) {
    this[y] = rr(t, e, n, o), tr(this[y]);
  }
  set(t, e, n, o) {
    throw new Error("set x() not implemented");
  }
  multiply(t, e, n, o) {
    if (x(t.w))
      return this.multiplyQuaternion(t);
    let s = Dt(t, e, n, o);
    return s ? this.multiplyQuaternion(new this.constructor(s)) : this.multiplyVector(t);
  }
  multiplyVector(t) {
    return ft(this, t);
  }
  multiplyQuaternion(t) {
    let e = this.x, n = this.y, o = this.z, s = this.w, i = t.x, u = t.y, h = t.z, c = t.w, f = s * i + e * c + n * h - o * u, d = s * u + n * c + o * i - e * h, V = s * h + o * c + e * u - n * i, M = s * c - e * i - n * u - o * h;
    return new this.constructor(f, d, V, M);
  }
  mul(t, e, n, o) {
    return this.multiply(t, e, n, o);
  }
  get inverse() {
    let { x: t, y: e, z: n, w: o } = this;
    return this.constructor(t * -1, e * -1, n * -1, o);
  }
  get inv() {
    return this.inverse;
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w;
  }
  get left() {
    return this.multiplyVector(st);
  }
  get dir() {
    return this.multiplyVector(ot);
  }
  get up() {
    return this.multiplyVector(it);
  }
  get [0]() {
    return this.left;
  }
  get [1]() {
    return this.dir;
  }
  get [2]() {
    return this.up;
  }
  get x() {
    return this[y][F];
  }
  set x(t) {
    throw new Error("set x() not implemented");
  }
  get y() {
    return this[y][J];
  }
  set y(t) {
    throw new Error("set y() not implemented");
  }
  get z() {
    return this[y][I];
  }
  set z(t) {
    throw new Error("set z() not implemented");
  }
  get w() {
    return this[y][D];
  }
  set w(t) {
    throw new Error("set w() not implemented");
  }
  toJSON() {
    let { x: t, y: e, z: n, w: o } = this;
    return { x: t, y: e, z: n, w: o, a1: 1 - e * e * 2 - n * n * 2, a2: t * e * 2 - n * o * 2, a3: t * n * 2 + e * o * 2, b1: t * e * 2 + n * o * 2, b2: 1 - t * t * 2 - n * n * 2, b3: e * n * 2 - t * o * 2, c1: t * n * 2 - e * o * 2, c2: e * n * 2 + t * o * 2, c3: 1 - t * t * 2 - e * e * 2 };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toCSSVars(t, e) {
    return b(t, this.toJSON(), e);
  }
};
N(U);
xt(U);
var ut = class extends U {
  set(t, e, n, o) {
    t instanceof U ? this[y] = [...t[y]] : (this[y] = rr(t, e, n, o), tr(this[y]));
  }
  set x(t) {
    this[y][F] = t;
  }
  set y(t) {
    this[y][J] = t;
  }
  set z(t) {
    this[y][I] = t;
  }
  set w(t) {
    this[y][D] = t;
  }
  get x() {
    return this[y][F];
  }
  get y() {
    return this[y][J];
  }
  get z() {
    return this[y][I];
  }
  get w() {
    return this[y][D];
  }
};
function zt(r, t, e) {
  let n = r[t];
  return n || (n = e(), r[t] = n), n;
}
var ht = class extends U {
  get left() {
    return zt(this, wr, () => this.multiplyVector(st));
  }
  get dir() {
    return zt(this, pr, () => this.multiplyVector(ot));
  }
  get up() {
    return zt(this, dr, () => this.multiplyVector(it));
  }
  get inverse() {
    return zt(this, xr, () => {
      let { x: t, y: e, z: n, w: o } = this;
      return this.constructor(t * -1, e * -1, n * -1, o);
    });
  }
};
var ae = new ut();
var Er = E((r, t, e, n) => new ut(r, t, e, n));
var Or = (r, t, e, n) => Er(r, t, e, n);
var Vr = E((r, t, e, n) => new ht(r, t, e, n));
var St = (r, t, e, n) => Vr(r, t, e, n);
var Mr = new ht(st, Y(90));
function qr({ alpha: r, beta: t, gamma: e }, n) {
  let o = St(it, Y(r)).mul(It, Y(t)).mul(ot, Y(e)).mul(Mr);
  return o = St(o.dir, Y(n)).mul(o), o;
}
var Nr = St(0, 0, 0, 1);
var Pt = 0;
var Gt = 1;
var kt = 2;
var Lt = 3;
var p = Symbol("axes");
var Z = class {
  constructor(t, e, n, o) {
    typeof t == "function" ? q(t, (s, i, u, h) => {
      this[p] = [s, i, u, h];
    }) : P(t) ? this[p] = [...t] : t && x(t.x) ? this[p] = [t.x || 0, t.y || 0, t.z || 0, t.w || 0] : this[p] = [t || 0, e || 0, n || 0, o || 0];
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  valueOf() {
    throw new Error("valueOf() not implemented, looks like you try to calculate outside of calc");
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  calc(t) {
    throw new Error("calc() not implemented");
  }
  clone() {
    throw new Error("clone() not implemented");
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w;
  }
  toJSON() {
    return { x: this.x, y: this.y, z: this.z, w: this.w };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toCSSVars(t, e) {
    return b(t, this.toJSON(), e);
  }
  get x() {
    return this[p][Pt];
  }
  set x(t) {
    throw new Error("set x() not implemented");
  }
  get y() {
    return this[p][Gt];
  }
  set y(t) {
    throw new Error("set y() not implemented");
  }
  get z() {
    return this[p][kt];
  }
  set z(t) {
    throw new Error("set z() not implemented");
  }
  get w() {
    return this[p][Lt];
  }
  set w(t) {
    throw new Error("set w() not implemented");
  }
  [Symbol.iterator]() {
    return this[p].values();
  }
};
N(Z);
X(Z, 4);
m(Z, "toArray");
var Q = class extends Z {
  set x(t) {
    this[p][Pt] = t;
  }
  set y(t) {
    this[p][Gt] = t;
  }
  set z(t) {
    this[p][kt] = t;
  }
  set w(t) {
    this[p][Lt] = t;
  }
  get x() {
    return this[p][Pt];
  }
  get y() {
    return this[p][Gt];
  }
  get z() {
    return this[p][kt];
  }
  get w() {
    return this[p][Lt];
  }
  calc(t) {
    return q(t, this);
  }
  clone() {
    return new Q(this.x, this.y);
  }
};
var Et = class extends Z {
  toColor() {
    return new Q(this.x, this.y, this.z, this.w);
  }
};
var br = E((r, t, e, n) => new Q(r, t, e, n));
var Cr = (r, t, e, n) => br(r, t, e, n);
var Ar = E((r, t, e, n) => new Et(r, t, e, n));
var Tr = (r, t, e, n) => Ar(r, t, e, n);
var lt = Symbol("data");
var $ = class {
  constructor(...t) {
    this[lt] = t;
  }
  get [0]() {
    return this[lt][0];
  }
  set [0](t) {
    throw new Error("set [0] not implemented");
  }
  get [1]() {
    return this[lt][1];
  }
  set [1](t) {
    throw new Error("set [1] not implemented");
  }
  get [2]() {
    return this[lt][2];
  }
  set [2](t) {
    throw new Error("set [2] not implemented");
  }
  multiplyMat(t) {
    return Yt(this, t);
  }
  multiplyVec(t) {
    return Ut(this, t);
  }
  multiply(t) {
    if (t instanceof $)
      return this.multiplyMat(t);
    let { x: e, y: n, z: o } = t;
    if (e === void 0 || n === void 0 || o === void 0)
      throw new Error(`multiply only works with mat3 and vec3, not supported ${t}`);
    return this.multiplyVec(t);
  }
  [Symbol.iterator]() {
    return this[lt].values();
  }
};
N($);
xt($);
var Ht = class extends $ {
};
var _r = Math.PI / 180;
var Rr = 180 / Math.PI;
function Fr(r) {
  return r * _r;
}
function Jr(r) {
  return r * Rr;
}
var Ee = _;
export {
  Q as Color,
  ct as Degree,
  ot as FORWARD,
  Et as IColor,
  Nr as IDENTITY,
  rt as IDegree,
  Ht as IMat3,
  T as IPoint,
  ht as IQuaternion,
  nt as IVector,
  st as LEFT,
  W as Point,
  ut as Quaternion,
  It as RIGHT,
  it as UP,
  _ as Vector,
  nt as Victor,
  q as calc,
  Cr as color,
  Ee as default,
  Y as degree,
  Jr as degrees,
  qr as fromOrientation,
  Tr as icolor,
  mr as idegree,
  gt as ipoint,
  St as iquaternion,
  C as ivector,
  ur as point,
  Or as quaternion,
  Fr as radians,
  ar as vector,
  C as victor
};
//# sourceMappingURL=@js-basics_vector.js.map
